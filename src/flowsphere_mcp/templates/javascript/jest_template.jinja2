/**
 * Generated Jest test from FlowSphere configuration.
 *
 * This file was auto-generated by FlowSphere MCP Server.
 * Configuration: {{ config.get('name', 'Unnamed Flow') }}
 * Generated: {{ generation_timestamp }}
 */

const axios = require('axios');
const { JSONPath } = require('jsonpath-plus');
const { v4: uuidv4 } = require('uuid');
const fs = require('fs');
const path = require('path');

/**
 * Base class for executing FlowSphere HTTP API sequences.
 */
class APISequence {
    constructor(config) {
        this.config = config;
        this.variables = config.variables || {};
        this.defaults = config.defaults || {};
        this.responses = {};
        this.userInputs = {};
        this.debug = config.enableDebug || false;
    }

    /**
     * Log debug messages if debug mode is enabled.
     */
    logDebug(message) {
        if (this.debug) {
            console.log(`[DEBUG] ${message}`);
        }
    }

    /**
     * Generate a new GUID/UUID.
     */
    generateGuid() {
        return uuidv4();
    }

    /**
     * Generate current Unix timestamp in milliseconds.
     */
    generateTimestamp() {
        return Date.now();
    }

    /**
     * Perform variable substitution on a value.
     *
     * Substitution order:
     * 1. Dynamic placeholders ({% raw %}{{ $guid }}{% endraw %}, {% raw %}{{ $timestamp }}{% endraw %})
     * 2. Global variables ({% raw %}{{ .vars.key }}{% endraw %})
     * 3. User input ({% raw %}{{ .input.variableName }}{% endraw %})
     * 4. Response references ({% raw %}{{ .responses.nodeId.field }}{% endraw %})
     */
    substituteVariables(value, stepTimestamp = null) {
        if (typeof value === 'string') {
            // Generate step timestamp once if not provided
            if (stepTimestamp === null) {
                stepTimestamp = this.generateTimestamp();
            }

            // 1. Dynamic placeholders
            // {% raw %}{{ $guid }}{% endraw %} - generate new UUID for each occurrence
            value = value.replace(/\{\{\s*\$guid\s*\}\}/g, () => this.generateGuid());

            // {% raw %}{{ $timestamp }}{% endraw %} - use same timestamp for the entire step
            value = value.replace(/\{\{\s*\$timestamp\s*\}\}/g, stepTimestamp.toString());

            // 2. Global variables - {% raw %}{{ .vars.key }}{% endraw %}
            for (const [varName, varValue] of Object.entries(this.variables)) {
                const pattern = new RegExp(`\\{\\{\\s*\\.vars\\.${varName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\}\\}`, 'g');
                value = value.replace(pattern, String(varValue));
            }

            // 3. User input - {% raw %}{{ .input.variableName }}{% endraw %}
            for (const [inputName, inputValue] of Object.entries(this.userInputs)) {
                const pattern = new RegExp(`\\{\\{\\s*\\.input\\.${inputName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\}\\}`, 'g');
                value = value.replace(pattern, String(inputValue));
            }

            // 4. Response references - {% raw %}{{ .responses.nodeId.field.subfield }}{% endraw %}
            const responsePattern = /\{\{\s*\.responses\.([a-zA-Z0-9_-]+)\.(.+?)\s*\}\}/g;
            const matches = [...value.matchAll(responsePattern)];

            for (const match of matches) {
                const [fullMatch, nodeId, jsonPath] = match;
                if (this.responses[nodeId]) {
                    const extractedValue = this.extractField(this.responses[nodeId], jsonPath);
                    if (extractedValue !== null && extractedValue !== undefined) {
                        value = value.replace(fullMatch, String(extractedValue));
                    }
                }
            }
        } else if (typeof value === 'object' && value !== null) {
            if (Array.isArray(value)) {
                return value.map(item => this.substituteVariables(item, stepTimestamp));
            } else {
                const result = {};
                for (const [key, val] of Object.entries(value)) {
                    result[key] = this.substituteVariables(val, stepTimestamp);
                }
                return result;
            }
        }

        return value;
    }

    /**
     * Extract field from response using JSONPath.
     */
    extractField(responseData, jsonPath) {
        try {
            // Handle simple field access
            if (!jsonPath.includes('.') && !jsonPath.includes('[')) {
                return responseData[jsonPath];
            }

            // Use JSONPath for complex expressions
            const result = JSONPath({ path: `$.${jsonPath}`, json: responseData });
            return result.length > 0 ? result[0] : null;
        } catch (error) {
            this.logDebug(`Error extracting field '${jsonPath}': ${error.message}`);
            return null;
        }
    }

    /**
     * Evaluate a FlowSphere condition.
     */
    evaluateConditions(conditions) {
        if (!conditions || conditions.length === 0) {
            return true;
        }

        // All conditions must pass (AND logic)
        for (const condition of conditions) {
            if (!this.evaluateCondition(condition)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Evaluate a single condition.
     */
    evaluateCondition(condition) {
        const leftValue = this.substituteVariables(condition.leftValue || '');
        const rightValue = this.substituteVariables(condition.rightValue || '');
        const operator = condition.operator || 'equals';

        this.logDebug(`Evaluating: ${leftValue} ${operator} ${rightValue}`);

        // Convert to strings for comparison
        const leftStr = String(leftValue);
        const rightStr = String(rightValue);

        const operators = {
            equals: (l, r) => l === r,
            notEquals: (l, r) => l !== r,
            contains: (l, r) => l.includes(r),
            notContains: (l, r) => !l.includes(r),
            greaterThan: (l, r) => parseFloat(l) > parseFloat(r),
            lessThan: (l, r) => parseFloat(l) < parseFloat(r),
            greaterThanOrEqual: (l, r) => parseFloat(l) >= parseFloat(r),
            lessThanOrEqual: (l, r) => parseFloat(l) <= parseFloat(r),
        };

        try {
            const evaluator = operators[operator] || operators.equals;
            return evaluator(leftStr, rightStr);
        } catch (error) {
            this.logDebug(`Error evaluating condition: ${error.message}`);
            return false;
        }
    }

    /**
     * Validate response against validations.
     */
    validateResponse(response, responseData, validations) {
        if (!validations || validations.length === 0) {
            return { success: true, errors: [] };
        }

        const errors = [];

        for (const validation of validations) {
            // HTTP status code validation
            if (validation.httpStatusCode !== undefined) {
                if (response.status !== validation.httpStatusCode) {
                    errors.push(`Expected status ${validation.httpStatusCode}, got ${response.status}`);
                }
            }

            // Field validation
            if (validation.field !== undefined) {
                const actualValue = this.extractField(responseData, validation.field);
                const expectedValue = this.substituteVariables(validation.value);

                const operator = validation.operator || 'equals';
                const tempCondition = {
                    leftValue: actualValue,
                    rightValue: expectedValue,
                    operator: operator
                };

                if (!this.evaluateCondition(tempCondition)) {
                    errors.push(`Field '${validation.field}': expected ${operator} '${expectedValue}', got '${actualValue}'`);
                }
            }
        }

        return {
            success: errors.length === 0,
            errors: errors
        };
    }

    /**
     * Execute an HTTP request for a node.
     */
    async executeHttpRequest(node) {
        const stepTimestamp = this.generateTimestamp();

        // Build URL
        const baseUrl = this.defaults.baseUrl || '';
        const url = this.substituteVariables(baseUrl + node.url, stepTimestamp);

        // Merge headers
        let headers = {};
        if (!node.skipDefaultHeaders) {
            headers = { ...this.defaults.headers };
        }
        if (node.headers) {
            headers = { ...headers, ...node.headers };
        }
        headers = this.substituteVariables(headers, stepTimestamp);

        // Prepare body
        let data = null;
        if (node.body) {
            data = this.substituteVariables(node.body, stepTimestamp);
        }

        // Get timeout
        const timeout = node.timeout || this.defaults.timeout || 30000;

        this.logDebug(`Executing ${node.method} ${url}`);

        try {
            // Execute request
            const response = await axios({
                method: node.method.toLowerCase(),
                url: url,
                headers: headers,
                data: data,
                timeout: timeout,
                validateStatus: () => true // Don't throw on any status
            });

            this.logDebug(`Response: ${response.status}`);

            // Store response
            let responseData = response.data;
            if (typeof responseData !== 'object') {
                responseData = { _text: String(responseData), _status: response.status };
            }

            this.responses[node.id] = responseData;

            // Extract fields if specified
            if (node.extractFields) {
                for (const fieldConfig of node.extractFields) {
                    const value = this.extractField(responseData, fieldConfig.jsonPath);
                    if (value !== null && value !== undefined) {
                        this.variables[fieldConfig.variableName] = value;
                        this.logDebug(`Extracted ${fieldConfig.variableName} = ${value}`);
                    }
                }
            }

            return { response, responseData };
        } catch (error) {
            this.logDebug(`Request failed: ${error.message}`);
            throw error;
        }
    }

    /**
     * Execute the complete API sequence.
     */
    async executeSequence() {
        const nodes = this.config.nodes || [];

        for (const node of nodes) {
            this.logDebug(`Processing node: ${node.id} - ${node.name}`);

            // Check if node should be skipped due to conditions
            if (node.condition) {
                if (!this.evaluateCondition(node.condition)) {
                    this.logDebug(`Skipping node ${node.id} due to failed condition`);
                    continue;
                }
            }

            // Handle user prompt
            if (node.promptMessage) {
                const variableName = node.variableName || node.id;
                // In test mode, use a default value
                this.userInputs[variableName] = `test_input_${variableName}`;
                this.logDebug(`User input '${variableName}' = '${this.userInputs[variableName]}'`);
            }

            // Handle browser launch (placeholder)
            if (node.launchBrowser) {
                this.logDebug('Browser launch requested (not implemented in test mode)');
            }

            // Execute HTTP request
            const { response, responseData } = await this.executeHttpRequest(node);

            // Validate response
            const validations = node.validations || (!node.skipDefaultValidations ? this.defaults.validations : null);
            if (validations) {
                const validationResult = this.validateResponse(response, responseData, validations);
                if (!validationResult.success) {
                    throw new Error(`Validation failed for node ${node.id}: ${validationResult.errors.join(', ')}`);
                }
            }
        }
    }
}

/**
 * Load FlowSphere configuration from JSON file.
 * @param {string} configFileName - Name of the config file (e.g., "config.json")
 * @returns {Object} Parsed configuration object
 * @throws {Error} If config file is not found
 */
function loadConfiguration(configFileName = 'config.json') {
    // Try multiple possible locations for the config file
    const possiblePaths = [
        configFileName,  // Current directory
        path.join(__dirname, configFileName),  // Same directory as test file
        path.join(__dirname, 'configuration', configFileName),  // configuration subfolder
        path.join(process.cwd(), configFileName),  // Working directory
        path.join(process.cwd(), 'configuration', configFileName),  // Working dir configuration subfolder
    ];

    for (const filePath of possiblePaths) {
        if (fs.existsSync(filePath)) {
            const configJson = fs.readFileSync(filePath, 'utf8');
            return JSON.parse(configJson);
        }
    }

    throw new Error(
        `Configuration file '${configFileName}' not found. Searched in: ${possiblePaths.join(', ')}`
    );
}

describe('{{ test_class_name }}', () => {
    let apiSequence;

    beforeEach(() => {
        const config = {{ config_json }};
        apiSequence = new APISequence(config);
    });

    test('should execute API sequence successfully', async () => {
        await expect(apiSequence.executeSequence()).resolves.not.toThrow();
    });

    test('should have correct configuration', () => {
        expect(apiSequence.config).toBeDefined();
        expect(apiSequence.config.nodes).toBeDefined();
        expect(apiSequence.config.nodes.length).toBeGreaterThan(0);
    });
});

// Export for use in other tests or as a module
module.exports = { APISequence };
