/**
 * Generated Cucumber Step Definitions from FlowSphere Configuration.
 *
 * This file was auto-generated by FlowSphere MCP Server.
 * Configuration: {{ config.get('name', 'Unnamed Flow') }}
 * Generated: {{ generation_timestamp }}
 */

const { Given, When, Then, Before, setWorldConstructor } = require('@cucumber/cucumber');
const axios = require('axios');
const { JSONPath } = require('jsonpath-plus');
const { v4: uuidv4 } = require('uuid');
const { expect } = require('chai');

/**
 * World class for managing API test state across cucumber steps.
 */
class APIWorld {
    constructor() {
        this.config = {{ config_json }};
        this.variables = this.config.variables || {};
        this.defaults = this.config.defaults || {};
        this.responses = {};
        this.userInputs = {};
        this.currentResponse = null;
        this.currentNodeId = null;
        this.debug = this.config.enableDebug || false;
        this.browserLaunched = false;
    }

    /**
     * Log debug messages if debug mode is enabled.
     */
    logDebug(message) {
        if (this.debug) {
            console.log(`[DEBUG] ${message}`);
        }
    }

    /**
     * Generate a new GUID/UUID.
     */
    generateGuid() {
        return uuidv4();
    }

    /**
     * Generate current Unix timestamp in milliseconds.
     */
    generateTimestamp() {
        return Date.now();
    }

    /**
     * Perform variable substitution on a value.
     */
    substituteVariables(value, stepTimestamp = null) {
        if (typeof value === 'string') {
            if (stepTimestamp === null) {
                stepTimestamp = this.generateTimestamp();
            }

            // Dynamic placeholders
            value = value.replace(/\{\{\s*\$guid\s*\}\}/g, () => this.generateGuid());
            value = value.replace(/\{\{\s*\$timestamp\s*\}\}/g, stepTimestamp.toString());

            // Global variables
            for (const [varName, varValue] of Object.entries(this.variables)) {
                const pattern = new RegExp(`\\{\\{\\s*\\.vars\\.${varName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\}\\}`, 'g');
                value = value.replace(pattern, String(varValue));
            }

            // User input
            for (const [inputName, inputValue] of Object.entries(this.userInputs)) {
                const pattern = new RegExp(`\\{\\{\\s*\\.input\\.${inputName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\}\\}`, 'g');
                value = value.replace(pattern, String(inputValue));
            }

            // Response references
            const responsePattern = /\{\{\s*\.responses\.([a-zA-Z0-9_-]+)\.(.+?)\s*\}\}/g;
            const matches = [...value.matchAll(responsePattern)];

            for (const match of matches) {
                const [fullMatch, nodeId, jsonPath] = match;
                if (this.responses[nodeId]) {
                    const extractedValue = this.extractField(this.responses[nodeId], jsonPath);
                    if (extractedValue !== null && extractedValue !== undefined) {
                        value = value.replace(fullMatch, String(extractedValue));
                    }
                }
            }
        } else if (typeof value === 'object' && value !== null) {
            if (Array.isArray(value)) {
                return value.map(item => this.substituteVariables(item, stepTimestamp));
            } else {
                const result = {};
                for (const [k, v] of Object.entries(value)) {
                    result[k] = this.substituteVariables(v, stepTimestamp);
                }
                return result;
            }
        }
        return value;
    }

    /**
     * Extract a field from response data using JSONPath or dot notation.
     */
    extractField(data, path) {
        try {
            if (path.startsWith('$')) {
                const result = JSONPath({ path: path, json: data });
                return result.length > 0 ? result[0] : null;
            }

            const parts = path.split('.');
            let current = data;
            for (const part of parts) {
                if (current === null || current === undefined) {
                    return null;
                }
                current = current[part];
            }
            return current;
        } catch (error) {
            this.logDebug(`Error extracting field "${path}": ${error.message}`);
            return null;
        }
    }

    /**
     * Evaluate a condition object.
     */
    evaluateCondition(condition) {
        const leftValue = this.substituteVariables(condition.leftValue);
        const rightValue = this.substituteVariables(condition.rightValue);
        const operator = condition.operator;

        this.logDebug(`Evaluating condition: ${leftValue} ${operator} ${rightValue}`);

        switch (operator) {
            case 'equals':
                return String(leftValue) === String(rightValue);
            case 'notEquals':
                return String(leftValue) !== String(rightValue);
            case 'contains':
                return String(leftValue).includes(String(rightValue));
            case 'notContains':
                return !String(leftValue).includes(String(rightValue));
            case 'greaterThan':
                return Number(leftValue) > Number(rightValue);
            case 'lessThan':
                return Number(leftValue) < Number(rightValue);
            case 'exists':
                return leftValue !== null && leftValue !== undefined;
            case 'notExists':
                return leftValue === null || leftValue === undefined;
            default:
                this.logDebug(`Unknown operator: ${operator}`);
                return false;
        }
    }
}

// Set the World constructor
setWorldConstructor(APIWorld);

// ===== Step Definitions =====

Given(/^I have provided user input for "([^"]*)"$/, function(nodeId) {
    // In test environment, use predefined values
    // In real scenarios, this would prompt the user
    this.logDebug(`User input requested for node: ${nodeId}`);
    // Pre-populate with test data if available
    if (this.config.testData && this.config.testData[nodeId]) {
        this.userInputs[nodeId] = this.config.testData[nodeId];
    }
});

Given(/^I have opened the browser$/, function() {
    this.browserLaunched = true;
    this.logDebug('Browser launch requested (skipped in automated tests)');
});

When(/^I execute (GET|POST|PUT|DELETE|PATCH) request to "([^"]*)"$/, async function(method, url) {
    const baseUrl = this.defaults.baseUrl || '';
    const fullUrl = baseUrl + this.substituteVariables(url);

    this.logDebug(`Executing ${method} request to: ${fullUrl}`);

    // Build headers
    let headers = {};
    if (this.defaults.headers) {
        headers = { ...this.defaults.headers };
    }

    const requestConfig = {
        method: method,
        url: fullUrl,
        headers: headers,
        timeout: this.defaults.timeout || 30000
    };

    this.lastRequestConfig = requestConfig;
});

When(/^I execute (GET|POST|PUT|DELETE|PATCH) request to "([^"]*)" with body$/, async function(method, url) {
    const baseUrl = this.defaults.baseUrl || '';
    const fullUrl = baseUrl + this.substituteVariables(url);

    this.logDebug(`Executing ${method} request to: ${fullUrl}`);

    let headers = {};
    if (this.defaults.headers) {
        headers = { ...this.defaults.headers };
    }

    const requestConfig = {
        method: method,
        url: fullUrl,
        headers: headers,
        timeout: this.defaults.timeout || 30000
    };

    this.lastRequestConfig = requestConfig;
});

When(/^I set the following headers:$/, function(dataTable) {
    const headers = {};
    const rows = dataTable.rawTable;
    for (const row of rows) {
        if (row.length >= 2) {
            headers[row[0]] = this.substituteVariables(row[1]);
        }
    }

    if (!this.lastRequestConfig) {
        this.lastRequestConfig = { headers: {} };
    }

    this.lastRequestConfig.headers = {
        ...this.lastRequestConfig.headers,
        ...headers
    };

    this.logDebug(`Headers set: ${JSON.stringify(headers)}`);
});

When(/^I set the request body to:$/, async function(docString) {
    const bodyStr = this.substituteVariables(docString);
    const body = JSON.parse(bodyStr);

    if (!this.lastRequestConfig) {
        throw new Error('No request configured. Use "When I execute..." first.');
    }

    this.lastRequestConfig.data = body;
    this.logDebug(`Request body set: ${JSON.stringify(body, null, 2)}`);

    // Execute the request now that we have the body
    try {
        this.currentResponse = await axios(this.lastRequestConfig);
        this.logDebug(`Response status: ${this.currentResponse.status}`);
        this.logDebug(`Response data: ${JSON.stringify(this.currentResponse.data, null, 2)}`);

        // Store response if we have a node ID
        if (this.currentNodeId) {
            this.responses[this.currentNodeId] = this.currentResponse.data;
        }
    } catch (error) {
        if (error.response) {
            this.currentResponse = error.response;
            this.logDebug(`HTTP error: ${error.response.status}`);
            if (this.currentNodeId) {
                this.responses[this.currentNodeId] = error.response.data;
            }
        } else {
            throw error;
        }
    }
});

Then(/^the response status code should be (\d+)$/, function(expectedStatus) {
    // If we haven't executed the request yet (no body), execute it now
    if (!this.currentResponse && this.lastRequestConfig) {
        return axios(this.lastRequestConfig)
            .then(response => {
                this.currentResponse = response;
                if (this.currentNodeId) {
                    this.responses[this.currentNodeId] = response.data;
                }
                expect(response.status).to.equal(parseInt(expectedStatus));
            })
            .catch(error => {
                if (error.response) {
                    this.currentResponse = error.response;
                    if (this.currentNodeId) {
                        this.responses[this.currentNodeId] = error.response.data;
                    }
                    expect(error.response.status).to.equal(parseInt(expectedStatus));
                } else {
                    throw error;
                }
            });
    }

    expect(this.currentResponse.status).to.equal(parseInt(expectedStatus));
});

Then(/^the response field "([^"]*)" should be "([^"]*)"$/, function(field, expectedValue) {
    const actualValue = this.extractField(this.currentResponse.data, field);
    const expected = this.substituteVariables(expectedValue);

    this.logDebug(`Validating field "${field}": ${actualValue} === ${expected}`);
    expect(String(actualValue)).to.equal(String(expected));
});

Then(/^I extract "([^"]*)" as "([^"]*)"$/, function(jsonPath, variableName) {
    const value = this.extractField(this.currentResponse.data, jsonPath);
    this.variables[variableName] = value;
    this.logDebug(`Extracted "${jsonPath}" as "${variableName}": ${value}`);
});
