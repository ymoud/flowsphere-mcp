/**
 * Generated Mocha test from FlowSphere configuration.
 *
 * This file was auto-generated by FlowSphere MCP Server.
 * Configuration: {{ config.get('name', 'Unnamed Flow') }}
 * Generated: {{ generation_timestamp }}
 */

const axios = require('axios');
const { JSONPath } = require('jsonpath-plus');
const { v4: uuidv4 } = require('uuid');
const { expect } = require('chai');
const fs = require('fs');
const path = require('path');

/**
 * Base class for executing FlowSphere HTTP API sequences.
 */
class APISequence {
    constructor(config) {
        this.config = config;
        this.variables = config.variables || {};
        this.defaults = config.defaults || {};
        this.responses = {};
        this.userInputs = {};
        this.debug = config.enableDebug || false;
    }

    /**
     * Log debug messages if debug mode is enabled.
     */
    logDebug(message) {
        if (this.debug) {
            console.log(`[DEBUG] ${message}`);
        }
    }

    /**
     * Generate a new GUID/UUID.
     */
    generateGuid() {
        return uuidv4();
    }

    /**
     * Generate current Unix timestamp in milliseconds.
     */
    generateTimestamp() {
        return Date.now();
    }

    /**
     * Perform variable substitution on a value.
     *
     * Substitution order:
     * 1. Dynamic placeholders ({% raw %}{{ $guid }}{% endraw %}, {% raw %}{{ $timestamp }}{% endraw %})
     * 2. Global variables ({% raw %}{{ .vars.key }}{% endraw %})
     * 3. User input ({% raw %}{{ .input.variableName }}{% endraw %})
     * 4. Response references ({% raw %}{{ .responses.nodeId.field }}{% endraw %})
     */
    substituteVariables(value, stepTimestamp = null) {
        if (typeof value === 'string') {
            // Generate step timestamp once if not provided
            if (stepTimestamp === null) {
                stepTimestamp = this.generateTimestamp();
            }

            // 1. Dynamic placeholders
            // {% raw %}{{ $guid }}{% endraw %} - generate new UUID for each occurrence
            value = value.replace(/\{\{\s*\$guid\s*\}\}/g, () => this.generateGuid());

            // {% raw %}{{ $timestamp }}{% endraw %} - use same timestamp for the entire step
            value = value.replace(/\{\{\s*\$timestamp\s*\}\}/g, stepTimestamp.toString());

            // 2. Global variables - {% raw %}{{ .vars.key }}{% endraw %}
            for (const [varName, varValue] of Object.entries(this.variables)) {
                const pattern = new RegExp(`\\{\\{\\s*\\.vars\\.${varName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\}\\}`, 'g');
                value = value.replace(pattern, String(varValue));
            }

            // 3. User input - {% raw %}{{ .input.variableName }}{% endraw %}
            for (const [inputName, inputValue] of Object.entries(this.userInputs)) {
                const pattern = new RegExp(`\\{\\{\\s*\\.input\\.${inputName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\s*\\}\\}`, 'g');
                value = value.replace(pattern, String(inputValue));
            }

            // 4. Response references - {% raw %}{{ .responses.nodeId.field.subfield }}{% endraw %}
            const responsePattern = /\{\{\s*\.responses\.([a-zA-Z0-9_-]+)\.(.+?)\s*\}\}/g;
            const matches = [...value.matchAll(responsePattern)];

            for (const match of matches) {
                const [fullMatch, nodeId, jsonPath] = match;
                if (this.responses[nodeId]) {
                    const extractedValue = this.extractField(this.responses[nodeId], jsonPath);
                    if (extractedValue !== null && extractedValue !== undefined) {
                        value = value.replace(fullMatch, String(extractedValue));
                    }
                }
            }
        } else if (typeof value === 'object' && value !== null) {
            if (Array.isArray(value)) {
                return value.map(item => this.substituteVariables(item, stepTimestamp));
            } else {
                const result = {};
                for (const [k, v] of Object.entries(value)) {
                    result[k] = this.substituteVariables(v, stepTimestamp);
                }
                return result;
            }
        }
        return value;
    }

    /**
     * Extract a field from response data using JSONPath or dot notation.
     */
    extractField(data, path) {
        try {
            // Try JSONPath first (handles arrays, complex paths)
            if (path.startsWith('$')) {
                const result = JSONPath({ path: path, json: data });
                return result.length > 0 ? result[0] : null;
            }

            // Simple dot notation for basic paths
            const parts = path.split('.');
            let current = data;
            for (const part of parts) {
                if (current === null || current === undefined) {
                    return null;
                }
                current = current[part];
            }
            return current;
        } catch (error) {
            this.logDebug(`Error extracting field "${path}": ${error.message}`);
            return null;
        }
    }

    /**
     * Evaluate a condition object.
     */
    evaluateCondition(condition) {
        const leftValue = this.substituteVariables(condition.leftValue);
        const rightValue = this.substituteVariables(condition.rightValue);
        const operator = condition.operator;

        this.logDebug(`Evaluating condition: ${leftValue} ${operator} ${rightValue}`);

        switch (operator) {
            case 'equals':
                return String(leftValue) === String(rightValue);
            case 'notEquals':
                return String(leftValue) !== String(rightValue);
            case 'contains':
                return String(leftValue).includes(String(rightValue));
            case 'notContains':
                return !String(leftValue).includes(String(rightValue));
            case 'greaterThan':
                return Number(leftValue) > Number(rightValue);
            case 'lessThan':
                return Number(leftValue) < Number(rightValue);
            case 'exists':
                return leftValue !== null && leftValue !== undefined;
            case 'notExists':
                return leftValue === null || leftValue === undefined;
            default:
                this.logDebug(`Unknown operator: ${operator}`);
                return false;
        }
    }

    /**
     * Check if node should be executed based on conditions.
     */
    shouldExecuteNode(node) {
        if (!node.conditions || node.conditions.length === 0) {
            return true;
        }

        // All conditions must pass (AND logic)
        for (const condition of node.conditions) {
            if (!this.evaluateCondition(condition)) {
                this.logDebug(`Condition failed for node ${node.id}: ${JSON.stringify(condition)}`);
                return false;
            }
        }

        return true;
    }

    /**
     * Execute a single node (HTTP request).
     */
    async executeNode(node) {
        // Check conditions
        if (!this.shouldExecuteNode(node)) {
            this.logDebug(`Skipping node ${node.id} due to failed conditions`);
            return null;
        }

        this.logDebug(`Executing node: ${node.id} - ${node.name}`);

        // Handle user prompts
        if (node.userPrompts && node.userPrompts.length > 0) {
            for (const prompt of node.userPrompts) {
                // In test environment, use predefined values or throw error
                if (!this.userInputs[prompt.variableName]) {
                    throw new Error(`User input required for "${prompt.variableName}" but not provided in test`);
                }
            }
        }

        // Handle browser launch (no-op in tests)
        if (node.launchBrowser) {
            this.logDebug('Browser launch requested (skipped in automated tests)');
        }

        // Build request URL
        const baseUrl = this.defaults.baseUrl || '';
        const url = baseUrl + this.substituteVariables(node.url);

        // Build headers
        let headers = {};
        if (!node.skipDefaultHeaders && this.defaults.headers) {
            headers = { ...this.defaults.headers };
        }
        if (node.headers) {
            headers = { ...headers, ...this.substituteVariables(node.headers) };
        }

        // Build request body
        let data = null;
        if (node.body) {
            data = this.substituteVariables(node.body);
        }

        // Build request config
        const requestConfig = {
            method: node.method.toUpperCase(),
            url: url,
            headers: headers,
            timeout: node.timeout || this.defaults.timeout || 30000,
        };

        if (data) {
            requestConfig.data = data;
        }

        this.logDebug(`Request: ${JSON.stringify(requestConfig, null, 2)}`);

        try {
            // Execute HTTP request
            const response = await axios(requestConfig);

            this.logDebug(`Response status: ${response.status}`);
            this.logDebug(`Response data: ${JSON.stringify(response.data, null, 2)}`);

            // Store response
            this.responses[node.id] = response.data;

            // Validate response
            await this.validateResponse(node, response);

            return response;
        } catch (error) {
            if (error.response) {
                // HTTP error response
                this.logDebug(`HTTP error: ${error.response.status}`);
                this.responses[node.id] = error.response.data;

                // Still validate (might expect error status)
                await this.validateResponse(node, error.response);

                throw error;
            } else {
                // Network or other error
                this.logDebug(`Request error: ${error.message}`);
                throw error;
            }
        }
    }

    /**
     * Validate response against node validations.
     */
    async validateResponse(node, response) {
        const validations = node.validations || [];

        // Skip default validations if flag is set
        if (!node.skipDefaultValidations && this.defaults.validations) {
            validations.unshift(...this.defaults.validations);
        }

        for (const validation of validations) {
            // HTTP status code validation
            if (validation.httpStatusCode !== undefined) {
                expect(response.status, `HTTP status code should be ${validation.httpStatusCode}`).to.equal(validation.httpStatusCode);
                this.logDebug(`✓ Status code validated: ${response.status}`);
            }

            // Field validation
            if (validation.field) {
                const actualValue = this.extractField(response.data, validation.field);
                const operator = validation.operator || 'equals';
                const expectedValue = this.substituteVariables(validation.value);

                this.logDebug(`Validating field "${validation.field}": ${actualValue} ${operator} ${expectedValue}`);

                switch (operator) {
                    case 'equals':
                        expect(String(actualValue), `Field "${validation.field}" should equal "${expectedValue}"`).to.equal(String(expectedValue));
                        break;
                    case 'notEquals':
                        expect(String(actualValue), `Field "${validation.field}" should not equal "${expectedValue}"`).to.not.equal(String(expectedValue));
                        break;
                    case 'contains':
                        expect(String(actualValue), `Field "${validation.field}" should contain "${expectedValue}"`).to.include(String(expectedValue));
                        break;
                    case 'notContains':
                        expect(String(actualValue), `Field "${validation.field}" should not contain "${expectedValue}"`).to.not.include(String(expectedValue));
                        break;
                    case 'greaterThan':
                        expect(Number(actualValue), `Field "${validation.field}" should be greater than ${expectedValue}`).to.be.greaterThan(Number(expectedValue));
                        break;
                    case 'lessThan':
                        expect(Number(actualValue), `Field "${validation.field}" should be less than ${expectedValue}`).to.be.lessThan(Number(expectedValue));
                        break;
                    case 'exists':
                        expect(actualValue, `Field "${validation.field}" should exist`).to.not.be.null;
                        expect(actualValue, `Field "${validation.field}" should exist`).to.not.be.undefined;
                        break;
                    case 'notExists':
                        expect(actualValue === null || actualValue === undefined, `Field "${validation.field}" should not exist`).to.be.true;
                        break;
                    default:
                        throw new Error(`Unknown validation operator: ${operator}`);
                }

                this.logDebug(`✓ Field validation passed`);
            }
        }
    }

    /**
     * Execute all nodes in sequence.
     */
    async run() {
        const nodes = this.config.nodes || [];
        this.logDebug(`Starting sequence with ${nodes.length} nodes`);

        for (const node of nodes) {
            await this.executeNode(node);
        }

        this.logDebug('Sequence completed successfully');
    }
}

/**
 * Load FlowSphere configuration from JSON file.
 * @param {string} configFileName - Name of the config file (e.g., "config.json")
 * @returns {Object} Parsed configuration object
 * @throws {Error} If config file is not found
 */
function loadConfiguration(configFileName = 'config.json') {
    // Try multiple possible locations for the config file
    const possiblePaths = [
        configFileName,  // Current directory
        path.join(__dirname, configFileName),  // Same directory as test file
        path.join(__dirname, 'configuration', configFileName),  // configuration subfolder
        path.join(process.cwd(), configFileName),  // Working directory
        path.join(process.cwd(), 'configuration', configFileName),  // Working dir configuration subfolder
    ];

    for (const filePath of possiblePaths) {
        if (fs.existsSync(filePath)) {
            const configJson = fs.readFileSync(filePath, 'utf8');
            return JSON.parse(configJson);
        }
    }

    throw new Error(
        `Configuration file '${configFileName}' not found. Searched in: ${possiblePaths.join(', ')}`
    );
}

// Configuration
const config = {{ config_json }};

// Test suite
describe('{{ config.get("name", "API Test Suite") }}', function() {
    // Increase timeout for API tests
    this.timeout(30000);

    let sequence;

    beforeEach(function() {
        sequence = new APISequence(config);
    });

{% for node in nodes %}
    it('{{ node.name or node.id }}', async function() {
        await sequence.executeNode(config.nodes[{{ loop.index0 }}]);
    });

{% endfor %}
    // Full sequence test
    it('Complete flow execution', async function() {
        await sequence.run();
    });
});
