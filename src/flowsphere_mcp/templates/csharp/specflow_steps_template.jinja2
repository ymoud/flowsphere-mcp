/**
 * Generated SpecFlow step definitions from FlowSphere configuration.
 *
 * This file was auto-generated by FlowSphere MCP Server.
 * Configuration: {{ config.get('name', 'Unnamed Flow') }}
 * Generated: {{ generation_timestamp }}
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using TechTalk.SpecFlow;
using NUnit.Framework;
using Newtonsoft.Json.Linq;

namespace {{ namespace }}
{
    [Binding]
    public class {{ step_class_name }}
    {
        private readonly Dictionary<string, object> _config;
        private readonly Dictionary<string, object> _variables;
        private readonly Dictionary<string, object> _defaults;
        private readonly Dictionary<string, object> _responses;
        private readonly Dictionary<string, string> _userInputs;
        private readonly bool _debug;
        private readonly HttpClient _httpClient;

        private HttpResponseMessage _lastResponse;
        private object _lastResponseData;
        private Dictionary<string, string> _currentHeaders;
        private object _currentBody;

        public {{ step_class_name }}()
        {
            _config = {{ config_json }};
            _variables = GetDictValue(_config, "variables") ?? new Dictionary<string, object>();
            _defaults = GetDictValue(_config, "defaults") ?? new Dictionary<string, object>();
            _responses = new Dictionary<string, object>();
            _userInputs = new Dictionary<string, string>();
            _debug = GetBoolValue(_config, "enableDebug", false);
            _httpClient = new HttpClient();
            _currentHeaders = new Dictionary<string, string>();

            // Set default timeout
            var timeout = GetIntValue(_defaults, "timeout", 30000);
            _httpClient.Timeout = TimeSpan.FromMilliseconds(timeout);
        }

        private void LogDebug(string message)
        {
            if (_debug)
            {
                Console.WriteLine($"[DEBUG] {message}");
            }
        }

        private string GenerateGuid()
        {
            return Guid.NewGuid().ToString();
        }

        private long GenerateTimestamp()
        {
            return DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        }

        private object SubstituteVariables(object value, long? stepTimestamp = null)
        {
            if (value is string strValue)
            {
                if (stepTimestamp == null)
                {
                    stepTimestamp = GenerateTimestamp();
                }

                // Dynamic placeholders
                strValue = System.Text.RegularExpressions.Regex.Replace(
                    strValue,
                    @"\{\{\s*\$guid\s*\}\}",
                    _ => GenerateGuid()
                );

                strValue = System.Text.RegularExpressions.Regex.Replace(
                    strValue,
                    @"\{\{\s*\$timestamp\s*\}\}",
                    stepTimestamp.ToString()
                );

                // Global variables
                foreach (var kvp in _variables)
                {
                    var pattern = @"\{\{\s*\.vars\." + System.Text.RegularExpressions.Regex.Escape(kvp.Key) + @"\s*\}\}";
                    strValue = System.Text.RegularExpressions.Regex.Replace(strValue, pattern, kvp.Value?.ToString() ?? "");
                }

                // User input
                foreach (var kvp in _userInputs)
                {
                    var pattern = @"\{\{\s*\.input\." + System.Text.RegularExpressions.Regex.Escape(kvp.Key) + @"\s*\}\}";
                    strValue = System.Text.RegularExpressions.Regex.Replace(strValue, pattern, kvp.Value);
                }

                // Response references
                var responsePattern = @"\{\{\s*\.responses\.([a-zA-Z0-9_-]+)\.(.+?)\s*\}\}";
                var matches = System.Text.RegularExpressions.Regex.Matches(strValue, responsePattern);

                foreach (System.Text.RegularExpressions.Match match in matches)
                {
                    var nodeId = match.Groups[1].Value;
                    var jsonPath = match.Groups[2].Value;

                    if (_responses.ContainsKey(nodeId))
                    {
                        var extractedValue = ExtractField(_responses[nodeId], jsonPath);
                        if (extractedValue != null)
                        {
                            strValue = strValue.Replace(match.Value, extractedValue.ToString());
                        }
                    }
                }

                return strValue;
            }
            else if (value is Dictionary<string, object> dict)
            {
                var result = new Dictionary<string, object>();
                foreach (var kvp in dict)
                {
                    result[kvp.Key] = SubstituteVariables(kvp.Value, stepTimestamp);
                }
                return result;
            }
            else if (value is List<object> list)
            {
                return list.Select(item => SubstituteVariables(item, stepTimestamp)).ToList();
            }

            return value;
        }

        private object ExtractField(object data, string path)
        {
            try
            {
                var jToken = JToken.FromObject(data);

                if (path.StartsWith("$"))
                {
                    var tokens = jToken.SelectTokens(path);
                    return tokens.FirstOrDefault()?.ToObject<object>();
                }

                // Simple dot notation
                var parts = path.Split('.');
                JToken current = jToken;

                foreach (var part in parts)
                {
                    if (current == null) return null;
                    current = current[part];
                }

                return current?.ToObject<object>();
            }
            catch (Exception ex)
            {
                LogDebug($"Error extracting field \"{path}\": {ex.Message}");
                return null;
            }
        }

        // ===== SpecFlow Step Definitions =====

        [Given(@"I have the API base URL from configuration")]
        public void GivenIHaveTheAPIBaseURLFromConfiguration()
        {
            var baseUrl = GetStringValue(_defaults, "baseUrl", "");
            LogDebug($"Base URL: {baseUrl}");
        }

        [When(@"I execute (GET|POST|PUT|DELETE|PATCH) request to ""([^""]*)""")]
        public async Task WhenIExecuteRequestTo(string method, string url)
        {
            // Get base URL from defaults
            var baseUrl = GetStringValue(_defaults, "baseUrl", "");
            var fullUrl = baseUrl + SubstituteVariables(url);

            LogDebug($"Executing {method} request to {fullUrl}");

            // Build request
            var request = new HttpRequestMessage(new HttpMethod(method), fullUrl);

            // Add headers
            foreach (var kvp in _currentHeaders)
            {
                request.Headers.TryAddWithoutValidation(kvp.Key, kvp.Value);
            }

            // Add body if present
            if (_currentBody != null)
            {
                var json = JsonSerializer.Serialize(_currentBody);
                request.Content = new StringContent(json, Encoding.UTF8, "application/json");
            }

            // Send request
            _lastResponse = await _httpClient.SendAsync(request);
            var responseBody = await _lastResponse.Content.ReadAsStringAsync();

            LogDebug($"Response status: {(int)_lastResponse.StatusCode}");
            LogDebug($"Response body: {responseBody}");

            // Parse response
            if (!string.IsNullOrEmpty(responseBody))
            {
                try
                {
                    _lastResponseData = JsonSerializer.Deserialize<object>(responseBody);
                }
                catch
                {
                    _lastResponseData = responseBody;
                }
            }

            // Reset headers and body for next request
            _currentHeaders.Clear();
            _currentBody = null;
        }

        [Given(@"I set the following headers")]
        [When(@"I set the following headers")]
        public void WhenISetTheFollowingHeaders(Table table)
        {
            foreach (var row in table.Rows)
            {
                var key = row[0];
                var value = SubstituteVariables(row[1])?.ToString();
                _currentHeaders[key] = value;
                LogDebug($"Header set: {key} = {value}");
            }
        }

        [Given(@"I set the request body")]
        [When(@"I set the request body")]
        public void WhenISetTheRequestBody()
        {
            // Body would be set from table or JSON string in real scenarios
            // For now, this is a placeholder
            LogDebug("Request body set");
        }

        [Then(@"the response status code should be (\d+)")]
        public void ThenTheResponseStatusCodeShouldBe(int expectedStatus)
        {
            Assert.That((int)_lastResponse.StatusCode, Is.EqualTo(expectedStatus),
                $"Expected status code {expectedStatus}, but got {(int)_lastResponse.StatusCode}");
            LogDebug($"âœ“ Status code validation passed: {expectedStatus}");
        }

        [Then(@"the response field ""([^""]*)"" should (equals|notEquals|contains|notContains|greaterThan|lessThan|exists|notExists) ""([^""]*)""")]
        public void ThenTheResponseFieldShould(string field, string op, string expectedValue)
        {
            var actualValue = ExtractField(_lastResponseData, field);
            var substitutedExpectedValue = SubstituteVariables(expectedValue);

            LogDebug($"Validating field \"{field}\": {actualValue} {op} {substitutedExpectedValue}");

            switch (op)
            {
                case "equals":
                    Assert.That(actualValue?.ToString(), Is.EqualTo(substitutedExpectedValue?.ToString()));
                    break;
                case "notEquals":
                    Assert.That(actualValue?.ToString(), Is.Not.EqualTo(substitutedExpectedValue?.ToString()));
                    break;
                case "contains":
                    Assert.That(actualValue?.ToString(), Does.Contain(substitutedExpectedValue?.ToString()));
                    break;
                case "notContains":
                    Assert.That(actualValue?.ToString(), Does.Not.Contain(substitutedExpectedValue?.ToString()));
                    break;
                case "greaterThan":
                    Assert.That(Convert.ToDouble(actualValue), Is.GreaterThan(Convert.ToDouble(substitutedExpectedValue)));
                    break;
                case "lessThan":
                    Assert.That(Convert.ToDouble(actualValue), Is.LessThan(Convert.ToDouble(substitutedExpectedValue)));
                    break;
                case "exists":
                    Assert.That(actualValue, Is.Not.Null);
                    break;
                case "notExists":
                    Assert.That(actualValue, Is.Null);
                    break;
            }

            LogDebug("âœ“ Field validation passed");
        }

        // Helper methods for safe dictionary access
        private Dictionary<string, object> GetDictValue(Dictionary<string, object> dict, string key)
        {
            return dict.ContainsKey(key) && dict[key] is Dictionary<string, object> d ? d : null;
        }

        private List<object> GetListValue(Dictionary<string, object> dict, string key)
        {
            return dict.ContainsKey(key) && dict[key] is List<object> list ? list : null;
        }

        private string GetStringValue(Dictionary<string, object> dict, string key, string defaultValue = "")
        {
            return dict.ContainsKey(key) ? dict[key]?.ToString() ?? defaultValue : defaultValue;
        }

        private bool GetBoolValue(Dictionary<string, object> dict, string key, bool defaultValue = false)
        {
            return dict.ContainsKey(key) && dict[key] is bool b ? b : defaultValue;
        }

        private int GetIntValue(Dictionary<string, object> dict, string key, int defaultValue = 0)
        {
            return dict.ContainsKey(key) ? Convert.ToInt32(dict[key]) : defaultValue;
        }

        private object GetValue(Dictionary<string, object> dict, string key)
        {
            return dict.ContainsKey(key) ? dict[key] : null;
        }
    }
}
