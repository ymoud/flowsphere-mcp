/**
 * Generated NUnit test from FlowSphere configuration.
 *
 * This file was auto-generated by FlowSphere MCP Server.
 * Configuration: {{ config.get('name', 'Unnamed Flow') }}
 * Generated: {{ generation_timestamp }}
 */

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;
using NUnit.Framework;
using Newtonsoft.Json.Linq;

namespace {{ namespace }}
{
    /// <summary>
    /// Base class for executing FlowSphere HTTP API sequences.
    /// </summary>
    public class APISequence
    {
        private readonly Dictionary<string, object> _config;
        private readonly Dictionary<string, object> _variables;
        private readonly Dictionary<string, object> _defaults;
        private readonly Dictionary<string, object> _responses;
        private readonly Dictionary<string, string> _userInputs;
        private readonly bool _debug;
        private readonly HttpClient _httpClient;

        public APISequence(Dictionary<string, object> config)
        {
            _config = config;
            _variables = GetDictValue(config, "variables") ?? new Dictionary<string, object>();
            _defaults = GetDictValue(config, "defaults") ?? new Dictionary<string, object>();
            _responses = new Dictionary<string, object>();
            _userInputs = new Dictionary<string, string>();
            _debug = GetBoolValue(config, "enableDebug", false);
            _httpClient = new HttpClient();

            // Set default timeout
            var timeout = GetIntValue(_defaults, "timeout", 30000);
            _httpClient.Timeout = TimeSpan.FromMilliseconds(timeout);
        }

        /// <summary>
        /// Log debug messages if debug mode is enabled.
        /// </summary>
        private void LogDebug(string message)
        {
            if (_debug)
            {
                Console.WriteLine($"[DEBUG] {message}");
            }
        }

        /// <summary>
        /// Generate a new GUID/UUID.
        /// </summary>
        private string GenerateGuid()
        {
            return Guid.NewGuid().ToString();
        }

        /// <summary>
        /// Generate current Unix timestamp in milliseconds.
        /// </summary>
        private long GenerateTimestamp()
        {
            return DateTimeOffset.UtcNow.ToUnixTimeMilliseconds();
        }

        /// <summary>
        /// Perform variable substitution on a value.
        /// </summary>
        private object SubstituteVariables(object value, long? stepTimestamp = null)
        {
            if (value is string strValue)
            {
                if (stepTimestamp == null)
                {
                    stepTimestamp = GenerateTimestamp();
                }

                // Dynamic placeholders
                strValue = System.Text.RegularExpressions.Regex.Replace(
                    strValue,
                    @"\{\{\s*\$guid\s*\}\}",
                    _ => GenerateGuid()
                );

                strValue = System.Text.RegularExpressions.Regex.Replace(
                    strValue,
                    @"\{\{\s*\$timestamp\s*\}\}",
                    stepTimestamp.ToString()
                );

                // Global variables
                foreach (var kvp in _variables)
                {
                    var pattern = @"\{\{\s*\.vars\." + System.Text.RegularExpressions.Regex.Escape(kvp.Key) + @"\s*\}\}";
                    strValue = System.Text.RegularExpressions.Regex.Replace(strValue, pattern, kvp.Value?.ToString() ?? "");
                }

                // User input
                foreach (var kvp in _userInputs)
                {
                    var pattern = @"\{\{\s*\.input\." + System.Text.RegularExpressions.Regex.Escape(kvp.Key) + @"\s*\}\}";
                    strValue = System.Text.RegularExpressions.Regex.Replace(strValue, pattern, kvp.Value);
                }

                // Response references
                var responsePattern = @"\{\{\s*\.responses\.([a-zA-Z0-9_-]+)\.(.+?)\s*\}\}";
                var matches = System.Text.RegularExpressions.Regex.Matches(strValue, responsePattern);

                foreach (System.Text.RegularExpressions.Match match in matches)
                {
                    var nodeId = match.Groups[1].Value;
                    var jsonPath = match.Groups[2].Value;

                    if (_responses.ContainsKey(nodeId))
                    {
                        var extractedValue = ExtractField(_responses[nodeId], jsonPath);
                        if (extractedValue != null)
                        {
                            strValue = strValue.Replace(match.Value, extractedValue.ToString());
                        }
                    }
                }

                return strValue;
            }
            else if (value is Dictionary<string, object> dict)
            {
                var result = new Dictionary<string, object>();
                foreach (var kvp in dict)
                {
                    result[kvp.Key] = SubstituteVariables(kvp.Value, stepTimestamp);
                }
                return result;
            }
            else if (value is List<object> list)
            {
                return list.Select(item => SubstituteVariables(item, stepTimestamp)).ToList();
            }

            return value;
        }

        /// <summary>
        /// Extract a field from response data using JSONPath or dot notation.
        /// </summary>
        private object ExtractField(object data, string path)
        {
            try
            {
                var jToken = JToken.FromObject(data);

                if (path.StartsWith("$"))
                {
                    var tokens = jToken.SelectTokens(path);
                    return tokens.FirstOrDefault()?.ToObject<object>();
                }

                // Simple dot notation
                var parts = path.Split('.');
                JToken current = jToken;

                foreach (var part in parts)
                {
                    if (current == null) return null;
                    current = current[part];
                }

                return current?.ToObject<object>();
            }
            catch (Exception ex)
            {
                LogDebug($"Error extracting field \"{path}\": {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Evaluate a condition object.
        /// </summary>
        private bool EvaluateCondition(Dictionary<string, object> condition)
        {
            var leftValue = SubstituteVariables(GetValue(condition, "leftValue"));
            var rightValue = SubstituteVariables(GetValue(condition, "rightValue"));
            var op = GetStringValue(condition, "operator");

            LogDebug($"Evaluating condition: {leftValue} {op} {rightValue}");

            return op switch
            {
                "equals" => leftValue?.ToString() == rightValue?.ToString(),
                "notEquals" => leftValue?.ToString() != rightValue?.ToString(),
                "contains" => leftValue?.ToString()?.Contains(rightValue?.ToString() ?? "") ?? false,
                "notContains" => !(leftValue?.ToString()?.Contains(rightValue?.ToString() ?? "") ?? false),
                "greaterThan" => Convert.ToDouble(leftValue) > Convert.ToDouble(rightValue),
                "lessThan" => Convert.ToDouble(leftValue) < Convert.ToDouble(rightValue),
                "exists" => leftValue != null,
                "notExists" => leftValue == null,
                _ => false
            };
        }

        /// <summary>
        /// Check if node should be executed based on conditions.
        /// </summary>
        private bool ShouldExecuteNode(Dictionary<string, object> node)
        {
            if (!node.ContainsKey("conditions")) return true;

            var conditions = GetListValue(node, "conditions");
            if (conditions == null || conditions.Count == 0) return true;

            foreach (var condition in conditions)
            {
                if (condition is Dictionary<string, object> condDict)
                {
                    if (!EvaluateCondition(condDict))
                    {
                        LogDebug($"Condition failed for node {GetStringValue(node, "id")}");
                        return false;
                    }
                }
            }

            return true;
        }

        /// <summary>
        /// Execute a single node (HTTP request).
        /// </summary>
        public async Task<HttpResponseMessage> ExecuteNodeAsync(Dictionary<string, object> node)
        {
            if (!ShouldExecuteNode(node))
            {
                LogDebug($"Skipping node {GetStringValue(node, "id")} due to failed conditions");
                return null;
            }

            var nodeId = GetStringValue(node, "id");
            var nodeName = GetStringValue(node, "name", nodeId);
            LogDebug($"Executing node: {nodeId} - {nodeName}");

            // Build request URL
            var baseUrl = GetStringValue(_defaults, "baseUrl", "");
            var url = baseUrl + SubstituteVariables(GetStringValue(node, "url"));

            // Build headers
            var headers = new Dictionary<string, string>();
            var skipDefaultHeaders = GetBoolValue(node, "skipDefaultHeaders", false);

            if (!skipDefaultHeaders && _defaults.ContainsKey("headers"))
            {
                var defaultHeaders = GetDictValue(_defaults, "headers");
                if (defaultHeaders != null)
                {
                    foreach (var kvp in defaultHeaders)
                    {
                        headers[kvp.Key] = kvp.Value?.ToString();
                    }
                }
            }

            if (node.ContainsKey("headers"))
            {
                var nodeHeaders = GetDictValue(node, "headers");
                if (nodeHeaders != null)
                {
                    foreach (var kvp in nodeHeaders)
                    {
                        headers[kvp.Key] = SubstituteVariables(kvp.Value)?.ToString();
                    }
                }
            }

            // Build request
            var method = GetStringValue(node, "method", "GET").ToUpper();
            var request = new HttpRequestMessage(new HttpMethod(method), url);

            foreach (var kvp in headers)
            {
                request.Headers.TryAddWithoutValidation(kvp.Key, kvp.Value);
            }

            // Add body if present
            if (node.ContainsKey("body"))
            {
                var body = SubstituteVariables(node["body"]);
                var json = JsonSerializer.Serialize(body);
                request.Content = new StringContent(json, Encoding.UTF8, "application/json");
            }

            LogDebug($"Request: {method} {url}");

            try
            {
                var response = await _httpClient.SendAsync(request);
                var responseBody = await response.Content.ReadAsStringAsync();

                LogDebug($"Response status: {(int)response.StatusCode}");
                LogDebug($"Response data: {responseBody}");

                // Store response
                object responseData = null;
                if (!string.IsNullOrEmpty(responseBody))
                {
                    try
                    {
                        responseData = JsonSerializer.Deserialize<object>(responseBody);
                    }
                    catch
                    {
                        responseData = responseBody;
                    }
                }
                _responses[nodeId] = responseData;

                // Validate response
                ValidateResponse(node, response, responseData);

                return response;
            }
            catch (HttpRequestException ex)
            {
                LogDebug($"Request error: {ex.Message}");
                throw;
            }
        }

        /// <summary>
        /// Validate response against node validations.
        /// </summary>
        private void ValidateResponse(Dictionary<string, object> node, HttpResponseMessage response, object responseData)
        {
            var validations = GetListValue(node, "validations") ?? new List<object>();

            var skipDefaultValidations = GetBoolValue(node, "skipDefaultValidations", false);
            if (!skipDefaultValidations && _defaults.ContainsKey("validations"))
            {
                var defaultValidations = GetListValue(_defaults, "validations");
                if (defaultValidations != null)
                {
                    validations.InsertRange(0, defaultValidations);
                }
            }

            foreach (var validation in validations)
            {
                if (validation is not Dictionary<string, object> valDict) continue;

                // HTTP status code validation
                if (valDict.ContainsKey("httpStatusCode"))
                {
                    var expectedStatus = Convert.ToInt32(valDict["httpStatusCode"]);
                    Assert.That((int)response.StatusCode, Is.EqualTo(expectedStatus),
                        $"Expected status code {expectedStatus}, but got {(int)response.StatusCode}");
                    LogDebug($"✓ Status code validated: {(int)response.StatusCode}");
                }

                // Field validation
                if (valDict.ContainsKey("field"))
                {
                    var field = GetStringValue(valDict, "field");
                    var actualValue = ExtractField(responseData, field);
                    var op = GetStringValue(valDict, "operator", "equals");
                    var expectedValue = SubstituteVariables(GetValue(valDict, "value"));

                    LogDebug($"Validating field \"{field}\": {actualValue} {op} {expectedValue}");

                    switch (op)
                    {
                        case "equals":
                            Assert.That(actualValue?.ToString(), Is.EqualTo(expectedValue?.ToString()));
                            break;
                        case "notEquals":
                            Assert.That(actualValue?.ToString(), Is.Not.EqualTo(expectedValue?.ToString()));
                            break;
                        case "contains":
                            Assert.That(actualValue?.ToString(), Does.Contain(expectedValue?.ToString()));
                            break;
                        case "notContains":
                            Assert.That(actualValue?.ToString(), Does.Not.Contain(expectedValue?.ToString()));
                            break;
                        case "greaterThan":
                            Assert.That(Convert.ToDouble(actualValue), Is.GreaterThan(Convert.ToDouble(expectedValue)));
                            break;
                        case "lessThan":
                            Assert.That(Convert.ToDouble(actualValue), Is.LessThan(Convert.ToDouble(expectedValue)));
                            break;
                        case "exists":
                            Assert.That(actualValue, Is.Not.Null);
                            break;
                        case "notExists":
                            Assert.That(actualValue, Is.Null);
                            break;
                    }

                    LogDebug("✓ Field validation passed");
                }
            }
        }

        // Helper methods for safe dictionary access
        private Dictionary<string, object> GetDictValue(Dictionary<string, object> dict, string key)
        {
            return dict.ContainsKey(key) && dict[key] is Dictionary<string, object> d ? d : null;
        }

        private List<object> GetListValue(Dictionary<string, object> dict, string key)
        {
            return dict.ContainsKey(key) && dict[key] is List<object> list ? list : null;
        }

        private string GetStringValue(Dictionary<string, object> dict, string key, string defaultValue = "")
        {
            return dict.ContainsKey(key) ? dict[key]?.ToString() ?? defaultValue : defaultValue;
        }

        private bool GetBoolValue(Dictionary<string, object> dict, string key, bool defaultValue = false)
        {
            return dict.ContainsKey(key) && dict[key] is bool b ? b : defaultValue;
        }

        private int GetIntValue(Dictionary<string, object> dict, string key, int defaultValue = 0)
        {
            return dict.ContainsKey(key) ? Convert.ToInt32(dict[key]) : defaultValue;
        }

        private object GetValue(Dictionary<string, object> dict, string key)
        {
            return dict.ContainsKey(key) ? dict[key] : null;
        }
    }

    /// <summary>
    /// Test class for {{ config.get('name', 'API Test Suite') }}
    /// </summary>
    [TestFixture]
    public class {{ test_class_name }}
    {
        private Dictionary<string, object> _config;

        [SetUp]
        public void SetUp()
        {
            _config = {{ config_json }};
        }

        /// <summary>
        /// Load FlowSphere configuration from JSON file.
        /// </summary>
        /// <param name="configFileName">Name of the config file (e.g., "config.json")</param>
        /// <returns>Parsed configuration dictionary</returns>
        private Dictionary<string, object> LoadConfiguration(string configFileName)
        {
            // Try multiple possible locations for the config file
            var possiblePaths = new[]
            {
                configFileName, // Current directory
                Path.Combine(AppContext.BaseDirectory, configFileName), // Executable directory
                Path.Combine(AppContext.BaseDirectory, "Configuration", configFileName), // Configuration subfolder
                Path.Combine(Directory.GetCurrentDirectory(), configFileName), // Working directory
                Path.Combine(Directory.GetCurrentDirectory(), "Configuration", configFileName) // Working dir Configuration subfolder
            };

            foreach (var path in possiblePaths)
            {
                if (File.Exists(path))
                {
                    var configJson = File.ReadAllText(path);
                    return JsonSerializer.Deserialize<Dictionary<string, object>>(configJson);
                }
            }

            throw new FileNotFoundException(
                $"Configuration file '{configFileName}' not found. Searched in: {string.Join(", ", possiblePaths)}"
            );
        }

{% for node in nodes %}
        [Test]
        public async Task {{ node.get('name', node.get('id', 'Test')) | replace(' ', '_') | replace('-', '_') }}()
        {
            var sequence = new APISequence(_config);
            var nodes = (_config["nodes"] as List<object>);
            var node = nodes[{{ loop.index0 }}] as Dictionary<string, object>;

            var response = await sequence.ExecuteNodeAsync(node);
            Assert.That(response, Is.Not.Null);
        }

{% endfor %}
        [Test]
        public async Task CompleteFlowExecution()
        {
            var sequence = new APISequence(_config);
            var nodes = (_config["nodes"] as List<object>);

            foreach (var nodeObj in nodes)
            {
                var node = nodeObj as Dictionary<string, object>;
                await sequence.ExecuteNodeAsync(node);
            }
        }
    }
}
