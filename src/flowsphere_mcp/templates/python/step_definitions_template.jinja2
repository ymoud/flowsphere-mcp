"""
Generated Behave Step Definitions from FlowSphere Configuration.

This file was auto-generated by FlowSphere MCP Server.
Configuration: {{ config.get('name', 'Unnamed Flow') }}
Generated: {{ generation_timestamp }}
"""

from behave import given, when, then, use_step_matcher
import requests
import json
import re
import time
import uuid
from typing import Dict, Any, Optional
from jsonpath_ng import parse as jsonpath_parse

# Use regex matcher for flexible step matching
use_step_matcher("re")


class APIContext:
    """Context class for managing API test state across behave steps."""

    def __init__(self, config: Dict[str, Any]):
        """Initialize API context with FlowSphere configuration."""
        self.config = config
        self.variables = config.get('variables', {})
        self.defaults = config.get('defaults', {})
        self.responses: Dict[str, Any] = {}
        self.user_inputs: Dict[str, str] = {}
        self.current_response = None
        self.current_node_id = None
        self.debug = config.get('enableDebug', False)
        self.browser_launched = False

    def log_debug(self, message: str):
        """Log debug messages if debug mode is enabled."""
        if self.debug:
            print(f"[DEBUG] {message}")

    def generate_guid(self) -> str:
        """Generate a new GUID/UUID."""
        return str(uuid.uuid4())

    def generate_timestamp(self) -> int:
        """Generate current Unix timestamp in milliseconds."""
        return int(time.time() * 1000)

    def substitute_variables(self, value: Any, step_timestamp: Optional[int] = None) -> Any:
        """
        Perform variable substitution on a value.

        Supports:
        - Dynamic placeholders: {% raw %}{{ $guid }}, {{ $timestamp }}{% endraw %}
        - Global variables: {% raw %}{{ .vars.key }}{% endraw %}
        - User input: {% raw %}{{ .input.variableName }}{% endraw %}
        - Response references: {% raw %}{{ .responses.nodeId.field }}{% endraw %}
        """
        if isinstance(value, str):
            if step_timestamp is None:
                step_timestamp = self.generate_timestamp()

            # Dynamic placeholders
            value = re.sub(r'\{\{\s*\$guid\s*\}\}', lambda m: self.generate_guid(), value)
            value = re.sub(r'\{\{\s*\$timestamp\s*\}\}', str(step_timestamp), value)

            # Global variables
            for var_name, var_value in self.variables.items():
                pattern = r'\{\{\s*\.vars\.' + re.escape(var_name) + r'\s*\}\}'
                value = re.sub(pattern, str(var_value), value)

            # User input
            for input_name, input_value in self.user_inputs.items():
                pattern = r'\{\{\s*\.input\.' + re.escape(input_name) + r'\s*\}\}'
                value = re.sub(pattern, str(input_value), value)

            # Response references
            response_pattern = r'\{\{\s*\.responses\.([a-zA-Z0-9_-]+)\.(.+?)\s*\}\}'
            matches = list(re.finditer(response_pattern, value))

            for match in matches:
                node_id, json_path = match.group(1), match.group(2)
                if node_id in self.responses:
                    extracted_value = self.extract_field(self.responses[node_id], json_path)
                    if extracted_value is not None:
                        value = value.replace(match.group(0), str(extracted_value))

        elif isinstance(value, dict):
            return {k: self.substitute_variables(v, step_timestamp) for k, v in value.items()}
        elif isinstance(value, list):
            return [self.substitute_variables(item, step_timestamp) for item in value]

        return value

    def extract_field(self, response_data: Any, json_path: str) -> Any:
        """Extract field from response using JSONPath."""
        try:
            # Handle simple field access
            if '.' not in json_path and '[' not in json_path:
                return response_data.get(json_path) if isinstance(response_data, dict) else None

            # Use JSONPath for complex expressions
            jsonpath_expr = jsonpath_parse(f"$.{json_path}")
            matches = jsonpath_expr.find(response_data)
            return matches[0].value if matches else None
        except Exception as e:
            self.log_debug(f"Error extracting field '{json_path}': {str(e)}")
            return None

    def evaluate_condition(self, condition: Dict[str, Any]) -> bool:
        """Evaluate a FlowSphere condition."""
        left_value = self.substitute_variables(condition.get('leftValue', ''))
        right_value = self.substitute_variables(condition.get('rightValue', ''))
        operator = condition.get('operator', 'equals')

        self.log_debug(f"Evaluating: {left_value} {operator} {right_value}")

        # Convert to strings for comparison
        left_str = str(left_value)
        right_str = str(right_value)

        operators = {
            'equals': lambda l, r: l == r,
            'notEquals': lambda l, r: l != r,
            'contains': lambda l, r: r in l,
            'notContains': lambda l, r: r not in l,
            'greaterThan': lambda l, r: float(l) > float(r),
            'lessThan': lambda l, r: float(l) < float(r),
            'greaterThanOrEqual': lambda l, r: float(l) >= float(r),
            'lessThanOrEqual': lambda l, r: float(l) <= float(r),
        }

        try:
            return operators.get(operator, operators['equals'])(left_str, right_str)
        except Exception as e:
            self.log_debug(f"Error evaluating condition: {str(e)}")
            return False


def get_api_context(context):
    """Get or create API context for behave context."""
    if not hasattr(context, 'api_context'):
        # Load FlowSphere configuration
        config = {{ config | tojson }}
        context.api_context = APIContext(config)
    return context.api_context


@given('I have provided user input for "(?P<node_id>[^"]+)"')
def step_provide_user_input(context, node_id):
    """Handle user input prompt for a node."""
    api_ctx = get_api_context(context)

    # Find node configuration
    node = next((n for n in api_ctx.config.get('nodes', []) if n.get('id') == node_id), None)
    if node and node.get('promptMessage'):
        prompt_message = node['promptMessage']
        variable_name = node.get('variableName', node_id)

        # In test mode, use a default value
        user_input = f"test_input_{variable_name}"
        api_ctx.user_inputs[variable_name] = user_input
        api_ctx.log_debug(f"User input '{variable_name}' = '{user_input}'")


@given('I have opened the browser')
def step_open_browser(context):
    """Mark browser as launched (placeholder for browser automation)."""
    api_ctx = get_api_context(context)
    api_ctx.browser_launched = True
    api_ctx.log_debug("Browser marked as launched")


@when('I execute (?P<method>GET|POST|PUT|DELETE|PATCH) request to "(?P<url>[^"]+)"(?: with body)?')
def step_execute_request(context, method, url):
    """Execute an HTTP request."""
    api_ctx = get_api_context(context)

    # Find the node by URL
    node = next((n for n in api_ctx.config.get('nodes', []) if n.get('url') == url), None)
    if not node:
        raise ValueError(f"No node found for URL: {url}")

    api_ctx.current_node_id = node.get('id')

    # Check conditions
    if node.get('condition'):
        if not api_ctx.evaluate_condition(node['condition']):
            api_ctx.log_debug(f"Condition failed for node {node['id']}, skipping")
            context.skip_validation = True
            return

    context.skip_validation = False

    # Build request
    step_timestamp = api_ctx.generate_timestamp()
    base_url = api_ctx.defaults.get('baseUrl', '')
    full_url = api_ctx.substitute_variables(base_url + url, step_timestamp)

    # Merge headers
    headers = {}
    if not node.get('skipDefaultHeaders', False):
        headers.update(api_ctx.defaults.get('headers', {}))
    if node.get('headers'):
        headers.update(node['headers'])
    headers = api_ctx.substitute_variables(headers, step_timestamp)

    # Prepare body
    body = None
    if node.get('body'):
        body = api_ctx.substitute_variables(node['body'], step_timestamp)

    # Get timeout
    timeout = node.get('timeout', api_ctx.defaults.get('timeout', 30))

    api_ctx.log_debug(f"Executing {method} {full_url}")

    # Execute request
    try:
        response = requests.request(
            method=method,
            url=full_url,
            headers=headers,
            json=body if body else None,
            timeout=timeout
        )

        # Store response
        api_ctx.current_response = response

        # Parse response body
        try:
            response_data = response.json()
        except:
            response_data = {"_text": response.text, "_status": response.status_code}

        # Store in responses dict
        api_ctx.responses[node['id']] = response_data

        # Extract fields if specified
        if node.get('extractFields'):
            for field_config in node['extractFields']:
                json_path = field_config['jsonPath']
                var_name = field_config['variableName']
                value = api_ctx.extract_field(response_data, json_path)
                if value is not None:
                    api_ctx.variables[var_name] = value
                    api_ctx.log_debug(f"Extracted {var_name} = {value}")

        api_ctx.log_debug(f"Response: {response.status_code}")

    except Exception as e:
        api_ctx.log_debug(f"Request failed: {str(e)}")
        raise


@when('I set the following headers')
def step_set_headers(context):
    """Set request headers (handled in execute_request step)."""
    # Headers are already handled in the main request step
    pass


@when('I set the request body to')
def step_set_body(context):
    """Set request body (handled in execute_request step)."""
    # Body is already handled in the main request step
    pass


@then('the response status code should be (?P<status_code>\\d+)')
def step_check_status_code(context, status_code):
    """Verify HTTP status code."""
    api_ctx = get_api_context(context)

    if getattr(context, 'skip_validation', False):
        return

    expected_status = int(status_code)
    actual_status = api_ctx.current_response.status_code

    assert actual_status == expected_status, \
        f"Expected status {expected_status}, got {actual_status}"


@then('the response field "(?P<field>[^"]+)" should be "(?P<value>[^"]+)"')
def step_check_field_value(context, field, value):
    """Verify response field value."""
    api_ctx = get_api_context(context)

    if getattr(context, 'skip_validation', False):
        return

    try:
        response_data = api_ctx.current_response.json()
    except:
        response_data = {"_text": api_ctx.current_response.text}

    actual_value = api_ctx.extract_field(response_data, field)
    expected_value = api_ctx.substitute_variables(value)

    assert str(actual_value) == str(expected_value), \
        f"Expected field '{field}' to be '{expected_value}', got '{actual_value}'"


@then('I extract "(?P<json_path>[^"]+)" as "(?P<variable_name>[^"]+)"')
def step_extract_field(context, json_path, variable_name):
    """Extract field from response and store as variable."""
    api_ctx = get_api_context(context)

    if getattr(context, 'skip_validation', False):
        return

    try:
        response_data = api_ctx.current_response.json()
    except:
        response_data = {"_text": api_ctx.current_response.text}

    value = api_ctx.extract_field(response_data, json_path)
    if value is not None:
        api_ctx.variables[variable_name] = value
        api_ctx.log_debug(f"Extracted {variable_name} = {value}")
