"""
Generated pytest test from FlowSphere configuration.

This file was auto-generated by FlowSphere MCP Server.
Configuration: {{ config.get('name', 'Unnamed Flow') }}
Generated: {{ generation_timestamp }}
"""

import pytest
import requests
import json
import time
import uuid
import re
import sys
import os
from typing import Dict, Any, List, Optional
from jsonpath_ng import parse as jsonpath_parse


class APISequence:
    """Base class for executing FlowSphere HTTP API sequences."""

    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.variables = config.get('variables', {})
        self.defaults = config.get('defaults', {})
        self.responses: Dict[str, Any] = {}
        self.user_inputs: Dict[str, str] = {}
        self.debug = config.get('enableDebug', False)

    def log_debug(self, message: str):
        if self.debug:
            print(f"[DEBUG] {message}")

    def generate_guid(self) -> str:
        return str(uuid.uuid4())

    def generate_timestamp(self) -> int:
        return int(time.time() * 1000)

    def substitute_variables(self, value: Any, step_timestamp: Optional[int] = None) -> Any:
        if isinstance(value, str):
            if step_timestamp is None:
                step_timestamp = self.generate_timestamp()

            value = re.sub(r'\{\{\s*\$guid\s*\}\}', lambda m: self.generate_guid(), value)
            value = re.sub(r'\{\{\s*\$timestamp\s*\}\}', str(step_timestamp), value)

            for var_name, var_value in self.variables.items():
                pattern = r'\{\{\s*\.vars\.' + re.escape(var_name) + r'\s*\}\}'
                value = re.sub(pattern, str(var_value), value)

            for input_name, input_value in self.user_inputs.items():
                pattern = r'\{\{\s*\.input\.' + re.escape(input_name) + r'\s*\}\}'
                value = re.sub(pattern, str(input_value), value)

            response_pattern = r'\{\{\s*\.responses\.([a-zA-Z0-9_-]+)\.(.+?)\s*\}\}'
            matches = re.finditer(response_pattern, value)

            for match in matches:
                node_id = match.group(1)
                field_path = match.group(2)

                if node_id in self.responses:
                    extracted_value = self.extract_field(self.responses[node_id], field_path)
                    if extracted_value is not None:
                        value = value.replace(match.group(0), str(extracted_value))

            return value

        elif isinstance(value, dict):
            return {k: self.substitute_variables(v, step_timestamp) for k, v in value.items()}
        elif isinstance(value, list):
            return [self.substitute_variables(item, step_timestamp) for item in value]
        else:
            return value

    def extract_field(self, data: Any, field_path: str) -> Any:
        try:
            if field_path.startswith('$'):
                jsonpath_expr = jsonpath_parse(field_path)
                matches = [match.value for match in jsonpath_expr.find(data)]
                return matches[0] if len(matches) == 1 else matches if matches else None

            parts = field_path.split('.')
            current = data

            for part in parts:
                if '[' in part and ']' in part:
                    key, index_str = part.split('[', 1)
                    index = int(index_str.rstrip(']'))
                    if key:
                        current = current[key][index]
                    else:
                        current = current[index]
                else:
                    current = current[part]

            return current

        except (KeyError, IndexError, TypeError, ValueError) as e:
            self.log_debug(f"Field extraction failed for {field_path}: {e}")
            return None

    def evaluate_conditions(self, node: Dict[str, Any]) -> bool:
        conditions = node.get('conditions', [])
        if not conditions:
            return True

        for condition in conditions:
            source = condition.get('node') or condition.get('variable') or condition.get('input')
            field = condition.get('field', '')
            operator = condition.get('operator')
            expected_value = condition.get('value')

            if expected_value is not None:
                expected_value = self.substitute_variables(expected_value)

            actual_value = None

            if condition.get('node'):
                node_id = condition['node']
                if node_id in self.responses:
                    if operator == 'statusCode':
                        actual_value = self.responses[node_id].get('_status_code')
                    elif field:
                        response_body = self.responses[node_id].get('body', {})
                        actual_value = self.extract_field(response_body, field)
                else:
                    return False
            elif condition.get('variable'):
                actual_value = self.variables.get(condition['variable'])
            elif condition.get('input'):
                actual_value = self.user_inputs.get(condition['input'])

            if not self._evaluate_operator(operator, actual_value, expected_value):
                return False

        return True

    def _evaluate_operator(self, operator: str, actual: Any, expected: Any) -> bool:
        try:
            if operator == 'statusCode':
                return actual == expected
            elif operator == 'equals':
                return actual == expected
            elif operator == 'notEquals':
                return actual != expected
            elif operator == 'exists':
                return actual is not None
            elif operator == 'greaterThan':
                return float(actual) > float(expected)
            elif operator == 'lessThan':
                return float(actual) < float(expected)
            elif operator == 'greaterThanOrEqual':
                return float(actual) >= float(expected)
            elif operator == 'lessThanOrEqual':
                return float(actual) <= float(expected)
            else:
                return False
        except (ValueError, TypeError):
            return False

    def validate_response(self, node: Dict[str, Any], response_data: Dict[str, Any]) -> List[str]:
        errors = []
        validations = []

        if not node.get('skipDefaultValidations', False):
            validations.extend(self.defaults.get('validations', []))

        validations.extend(node.get('validations', []))

        if not validations:
            validations = [{'httpStatusCode': 200}]

        for validation in validations:
            if 'httpStatusCode' in validation:
                expected_status = validation['httpStatusCode']
                actual_status = response_data.get('_status_code')
                if actual_status != expected_status:
                    errors.append(f"HTTP status validation failed: expected {expected_status}, got {actual_status}")

            if 'field' in validation:
                field_path = validation['field']
                expected_value = validation.get('value')

                if expected_value is not None:
                    expected_value = self.substitute_variables(expected_value)

                response_body = response_data.get('body', {})
                actual_value = self.extract_field(response_body, field_path)

                if expected_value is not None:
                    if actual_value != expected_value:
                        errors.append(f"Field validation failed for {field_path}: expected {expected_value}, got {actual_value}")
                elif actual_value is None:
                    errors.append(f"Field validation failed: {field_path} not found in response")

        return errors

    def execute_http_request(self, node: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Execute HTTP request for a node."""
        # Build URL
        url = self.build_url(node)

        # Build headers
        headers = self.build_headers(node)

        # Build body
        body = self.build_body(node)

        # Get timeout
        timeout = node.get('timeout', self.defaults.get('timeout', 30))

        # Get method
        method = node['method'].upper()

        self.log_debug(f"Executing {method} {url}")
        self.log_debug(f"Headers: {headers}")
        if body:
            self.log_debug(f"Body: {body}")

        try:
            # Execute request
            if method == 'GET':
                response = requests.get(url, headers=headers, timeout=timeout)
            elif method == 'POST':
                response = requests.post(url, headers=headers, data=body, timeout=timeout)
            elif method == 'PUT':
                response = requests.put(url, headers=headers, data=body, timeout=timeout)
            elif method == 'DELETE':
                response = requests.delete(url, headers=headers, timeout=timeout)
            elif method == 'PATCH':
                response = requests.patch(url, headers=headers, data=body, timeout=timeout)
            else:
                raise ValueError(f"Unsupported HTTP method: {method}")

            # Parse response body
            try:
                response_body = response.json()
            except json.JSONDecodeError:
                response_body = response.text

            result = {
                '_status_code': response.status_code,
                'body': response_body,
                'headers': dict(response.headers)
            }

            self.log_debug(f"Response status: {response.status_code}")
            self.log_debug(f"Response body: {response_body}")

            return result

        except requests.Timeout:
            raise AssertionError(f"Request timeout after {timeout} seconds")
        except requests.RequestException as e:
            raise AssertionError(f"Request failed: {str(e)}")

    def build_url(self, node: Dict[str, Any]) -> str:
        url = node['url']
        url = self.substitute_variables(url)

        if not url.startswith('http://') and not url.startswith('https://'):
            base_url = self.defaults.get('baseUrl', '')
            url = base_url.rstrip('/') + '/' + url.lstrip('/')

        return url

    def build_headers(self, node: Dict[str, Any]) -> Dict[str, str]:
        headers = {}

        if not node.get('skipDefaultHeaders', False):
            headers.update(self.defaults.get('headers', {}))

        headers.update(node.get('headers', {}))
        headers = self.substitute_variables(headers)

        return headers

    def build_body(self, node: Dict[str, Any]) -> Optional[str]:
        body = node.get('body')
        if body is None:
            return None

        body = self.substitute_variables(body)

        if isinstance(body, dict):
            return json.dumps(body)

        return str(body)


class Test{{ test_class_name }}(APISequence):
    """
    Test class for: {{ config.get('name', 'FlowSphere API Sequence') }}
    {% if config.get('description') %}
    Description: {{ config.description }}
    {% endif %}
    """

    @staticmethod
    def load_configuration(config_filename: str = "config.json") -> Dict[str, Any]:
        """
        Load FlowSphere configuration from JSON file.

        Args:
            config_filename: Name of the config file (e.g., "config.json")

        Returns:
            Parsed configuration dictionary

        Raises:
            FileNotFoundError: If config file is not found
        """
        # Try multiple possible locations for the config file
        possible_paths = [
            config_filename,  # Current directory
            os.path.join(os.path.dirname(__file__), config_filename),  # Same directory as test file
            os.path.join(os.path.dirname(__file__), "configuration", config_filename),  # configuration subfolder
            os.path.join(os.getcwd(), config_filename),  # Working directory
            os.path.join(os.getcwd(), "configuration", config_filename),  # Working dir configuration subfolder
        ]

        for path in possible_paths:
            if os.path.exists(path):
                with open(path, 'r', encoding='utf-8') as f:
                    return json.load(f)

        raise FileNotFoundError(
            f"Configuration file '{config_filename}' not found. Searched in: {', '.join(possible_paths)}"
        )

    @pytest.fixture(autouse=True)
    def setup(self):
        """Setup test configuration."""
        self.config = {{ config_json }}
        self.__init__(self.config)

    def test_execute_sequence(self):
        """Execute the complete API sequence."""
        nodes = self.config.get('nodes', [])

        {% if config.get('userPrompts') %}
        # Collect user prompts
        {% for prompt in config.get('userPrompts', []) %}
        # User prompt: {{ prompt.get('message', '') }}
        {% if prompt.get('defaultValue') %}
        self.user_inputs['{{ prompt.variableName }}'] = '{{ prompt.defaultValue }}'
        {% else %}
        # Note: In generated tests, user prompts need default values or should be mocked
        self.user_inputs['{{ prompt.variableName }}'] = 'test_value'
        {% endif %}
        {% endfor %}
        {% endif %}

        # Execute each node
        for node in nodes:
            node_id = node['id']
            node_name = node['name']

            self.log_debug(f"\\n=== Processing node: {node_id} - {node_name} ===")

            # Evaluate conditions
            if not self.evaluate_conditions(node):
                self.log_debug(f"Skipping node {node_id} - conditions not met")
                self.responses[node_id] = None
                continue

            {% if config.get('enableBrowserLaunch') %}
            # Browser launch support (not implemented in generated code)
            if node.get('browserLaunch'):
                self.log_debug("Browser launch requested but not supported in generated pytest code")
            {% endif %}

            # Execute HTTP request
            response_data = self.execute_http_request(node)

            # Store response
            self.responses[node_id] = response_data

            # Validate response
            validation_errors = self.validate_response(node, response_data)

            if validation_errors:
                error_msg = f"Node {node_id} ({node_name}) validation failed:\\n" + "\\n".join(validation_errors)
                raise AssertionError(error_msg)

            self.log_debug(f"Node {node_id} completed successfully")

        self.log_debug("\\n=== All nodes completed successfully ===")


if __name__ == '__main__':
    # Allow running test directly with python
    pytest.main([__file__, '-v'])
